# Intro into backend in Java/Kotlin (Spring Boot)

### JVM and it's languages:
The JVM (Java Virtual Machine) is a powerful engine that allows applications written in various programming languages to run on any platform that has a JVM installed. 

Initially designed for Java, the JVM is language-agnostic and supports multiple languages like Kotlin, Groovy, Scala, and Clojure, in addition to Java. It works by converting code from these languages into bytecode, which the JVM executes, providing platform independence and enabling features like memory management (garbage collection) and performance optimizations. 

JVM is quite similar to the .NET CLR (Common Language Runtime) in concept. Both are runtime environments designed to allow applications written in various languages to run on multiple platforms through an intermediate layer. The JVM executes bytecode generated by languages like Java, Kotlin, Scala, and Groovy, while the CLR executes Microsoft Intermediate Language (MSIL) or Common Intermediate Language (CIL) generated by .NET languages like C#, VB.NET, and F#

---------

### Spring Boot and it's ecosystem:

Spring Boot is a popular framework for building Java and Kotlin applications, especially web services and microservices, with minimal setup and configuration. It simplifies development by providing built-in defaults and tools like auto-configuration and starter templates for common tasks like web development, security, and database access.
Mainly used for big systems and enterprise projects.

Spring boot - is a modular framework with additional libraries to extend it's functionality: 
Here are the main components in a Spring project that you’ll encounter:

- Spring Core: Manages the lifecycle of beans (objects) and handles dependency injection.
- Spring Boot: Makes Spring development faster and easier with auto-configuration and opinionated defaults.
- Spring MVC: A framework for building web applications with HTTP requests, controllers, and responses.
- Spring Data: Provides easy integration with databases.
- Spring Security: Handles authentication and authorization.
- etc...

In a Spring Boot project, you can use both Java and Kotlin together seamlessly, since both languages run on the JVM. Spring Boot fully supports Kotlin, so you can mix Java and Kotlin classes within the same project. The build tools like Maven and Gradle allow you to include both Java and Kotlin dependencies and compile them together. You can write certain parts of your code in Java and others in Kotlin, depending on your preference or the task. Kotlin's concise syntax and modern features complement Java's robustness, giving you flexibility to choose the best language for each part of your project while maintaining compatibility across the entire Spring Boot ecosystem.

---------

### Dependencies:

In Java/Kotlin, dependencies are managed through Maven or Gradle (2 alternatives, similar to pip or npm), which are popular build tools in the Java ecosystem. These tools handle all the external libraries your project needs by specifying them in a file (pom.xml for Maven or build.gradle for Gradle). 

For example, if your project requires a database connection or a web server, you add the corresponding dependencies, and Maven or Gradle will automatically download and configure those libraries. Spring Boot also provides starter dependencies, which bundle related libraries into one package, making it easier to add common functionality like web services or security without manually configuring each library. This approach streamlines project setup and ensures consistent dependency management.

To use these starter dependecies as well as bootstrap your Spring Boot project - use the following website to: choose the project language, add dependencies, choose between Maven and Gradle: [https://start.spring.io/](https://start.spring.io/)
Similar bootstraping functionality can be in your IDE.

---

### Annotations:

In Spring (and Java/Kotlin in general), annotations are used to provide metadata and instructions about how the code should behave (like decorators in Python but with a broader impact on the Spring runtime)

Here are brief examples of annotations from **Java**, **Lombok** (library for simplifying code in Java - may not be used in Kotlin), and **Spring**, along with explanations of what they do:

### 1. **Java Annotation: `@Override`**
```java
public class MyClass extends ParentClass {
    @Override
    public void someMethod() {
        System.out.println("Overridden method.");
    }
}
```
- **What it does**: The `@Override` annotation tells the compiler that the method is overriding a method from a superclass. It's not required, but it helps catch errors, such as misspelling the method name or mismatching parameters.

---

### 2. **Lombok Annotation: `@Getter` and `@Setter`**

```java
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class User {
    private String name;
    private String email;
    private int age;
    private String address;
    private String phoneNumber;
}
```

### Explanation:
- The `@Getter` and `@Setter` annotations are applied at the **class level**, so Lombok generates getter and setter methods for **all fields** (`name`, `email`, `age`, `address`, and `phoneNumber`), reducing boilerplate code.


---

### 3. **Spring Annotation: `@RestController`**
```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}
```
- **What it does**: The `@RestController` annotation tells Spring that this class will handle web requests and return data (usually in JSON format). Combined with `@GetMapping`, it defines a route (`/hello`) and a method (`hello`) that handles GET requests and returns the response.

---

### Summary:
- **Java’s `@Override`** ensures you're correctly overriding methods.
- **Lombok’s `@Getter`/`@Setter`** automatically generate boilerplate getter and setter methods.
- **Spring’s `@RestController`** and `@GetMapping` handle web requests and send responses in a Spring Boot web application.

_________________________

### Tools and IDE Integration

Recommend IDEs that make working with Spring Boot easier:
- **IntelliJ IDEA** (supports Java, Kotlin, and Spring Boot natively) with Spring Boot extensions.
- **Visual Studio Code** with the Spring Boot extension pack for lightweight Spring development.

Spring Boot projects can be easily bootstrapped and configured in these IDEs using the **Spring Initializr**.

---

### Practical Project Structure and Best Practices

1. **Layered Architecture**:
   - **Controller Layer**: Handle HTTP requests (e.g., `@RestController`).
   - **Service Layer**: Business logic (e.g., `@Service`).
   - **Repository Layer**: Data access using `@Repository` and Spring Data.

2. **DTOs and Entity separation**:  
   Use **Data Transfer Objects (DTOs)** for transferring data between client and server, separating them from **Entities** (which map to database tables).

---

### Hands-On Learning

Suggest building a small **REST API** that performs CRUD operations, interacting with a database using **Spring Data JPA**. You could include:
- A **PostgreSQL** or **H2** database for persistence.
- API endpoints for basic `create`, `read`, `update`, and `delete` functionality.
- A **User** or **Product** entity for the data model.

---

### Recommended Next Steps

1. Start by creating a basic **Hello World** Spring Boot app, gradually adding more features like database access, REST APIs, and security.
2. Encourage using **Kotlin** in parts of the project to become familiar with Kotlin’s expressive syntax while mixing with Java where necessary.
3. Leverage **Spring Boot Starters** and auto-configuration for rapid development, and customize configuration once more comfortable with the basics.
